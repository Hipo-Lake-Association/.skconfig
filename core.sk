# Basic script configurations
#
# This script facilitates access to Skript's built-in configuration format,
# by mapping the tree-structure of the file to a variable.
#
# Any file respecting Skript's default config structure can be parsed and its
# contents mapped to a list variable. All previous, non-conflicting elements
# of the variable are not cleared.
# A file violating the config structure will fail to be mapped and, by default,
# output will be sent to the console.
#
# Mapping is, by default, done asynchronously through all sub-nodes in a recursive manner.
#
# Values of entries go through the registered parsers. A value that cannot be parsed
# fails to be added to the resulting variable and an error is thrown.
#
# User-defined parsers (auxiliary parsers) are stored in a special list variable.



import:
    java.io.File
    ch.njol.skript.Skript
    ch.njol.skript.config.Config
    ch.njol.skript.config.SectionNode
    ch.njol.skript.config.EntryNode
    ch.njol.skript.lang.function.Function
    ch.njol.skript.lang.ParseContext
    ch.njol.skript.lang.Variable
    ch.njol.skript.log.SkriptLogger
    ch.njol.skript.registrations.Classes
    ch.njol.skript.variables.Variables
    com.btk5h.skriptmirror.FunctionWrapper
    com.btk5h.skriptmirror.skript.reflect.sections.Section

options:
    # A config's file extension.
    # It is generally not recommended to modify this due to the risk of
    # breaking compatibility with other scripts/configurations.
    file-extension: ".skconfig"

    # The key-value separator for entry nodes.
    # A colon is used by default for parity with Skript's standard format.
    node-separator: ":"

    # Whether or not to send loading output (errors, warnings, etc.).
    # This is sent to the console recipient at runtime.
    show-loading-output: true

# Maps the contents of a config to a list variable.
# This fails for inexistent files or files that violate the format.
effect load [script] config[uration] %string% into %~objects%:
    parse:
        expr-2 is instance of Variable
        expr-2.isList() is true
        continue
    trigger:
        delay the effect

        set {_path} to expr-1
        if {_path} does not end with {@file-extension}:
            set {_path} to join {_path} and {@file-extension}
        set {_file} to new File({_path})

        stop if {_file}.exists() is false

        # Retains all parsing output and prints it only if required to do so.
        set {_handler} to SkriptLogger.startRetainingLog()

        set {_config} to new Config({_file}, true, true, {@node-separator})
        set {_root} to {_config}.getMainNode()
        {_root}.convertToEntries(-1)

        {_handler}.stop()

        {_handler}.printErrors() if {@show-loading-output} is true
        stop if {_handler}.hasErrors() is true

        set {_variable} to (raw expr-2).getName().getSingle(event)
        set {_variable} to first (length of {_variable} - 3) characters of {_variable}
        set {_local} to (raw expr-2).isLocal()

        # This can probably be swapped for a direct replacement of the variable's tree with the
        # config's tree, but doing it in this fashion simplifies the work of adding type converters.
        create new section with {_variable}, {_local}, {_event}, {_node}, {_section} stored in {_section-mapper}:
            if {_node} is an instance of EntryNode:
                set {_value::*} to parsed config value ({_node}.getValue())
                if {_value::*} is not set:
                    if {@show-loading-output} is true:
                        SkriptLogger.setNode({_node})
                        Skript.error("Can't understand the value '%{_node}.getValue()%'")
                else: # Do not overwrite existing value with null.
                    if size of {_value::*} is 1:
                        Variables.setVariable({_variable}, {_value::1}, {_event}, {_local})
                    else:
                        loop {_value::*}:
                            set {_key} to join {_variable}, (Variable.SEPARATOR), loop-index
                            Variables.setVariable({_key}, loop-value, {_event}, {_local})
            else if {_node} is an instance of SectionNode:
                loop ...{_node}:
                    set {_key} to join {_variable}, (Variable.SEPARATOR), (loop-value.getKey())
                    run section {_section} with {_key}, {_local}, {_event}, loop-value, {_section} and wait

        run section {_section-mapper} async with {_variable}, {_local}, event, {_root} and {_section-mapper} and wait
        continue

# Registers a user-defined parser with the given string identifier.
# This accepts monadic sections or references to monadic functions.
#
# For plain parsers of class infos, it is recommended to use the class info's code name
# as the string identifier of the auxiliary parser.
effect register [a] [new] [script] config[uration] [value] %string% parser (with|using) %object%:
    trigger:
        stop if expr-2 is not instance of Section, Function or FunctionWrapper
        set {_parser} to expr-2
        if {_parser} is an instance of FunctionWrapper:
            set {_parser} to {_parser}.getFunction() # unwrap
        set {-.skconfig::parsers::%expr-1%} to {_parser}


# Attempts to parse the given input string using the available parsers.
# This first goes through the default parsers, then through auxiliary ones.
#
# Multiple values can be returned and will be mapped with numerical indices starting from 1.
local plural expression parsed config value %string%:
    return type: objects
    get:
        # Default parsers
        loop "java.lang.String", "java.lang.Integer", "java.lang.Double", "java.lang.Boolean":
            set {_result} to Classes.parseSimple(expr-1, (class loop-value), ParseContext.SCRIPT)
            return {_result} if {_result} is set

        # Auxiliary parsers
        loop {-.skconfig::parsers::*}:
            if loop-value is an instance of Function:
                set {_result::*} to ...loop-value.execute([[expr-1]])
            else:
                run section loop-value with expr-1 and store the result in {_result::*}
            return {_result::*} if {_result::*} is set

        return
